<!doctype html>
<html lang="ru">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>$TALK — чат + TLK wallet (Firebase)</title>
<meta name="theme-color" content="#1e90ff"/>
<style>
/* (Упрощённые стили — mobile-first) */
:root{--primary:#1e90ff;--bg:#f6f8fb;--card:#fff;--muted:#6b7280;--text:#111;--danger:#ff4d4f;--me:#dbeafe;--you:#f2f3f5;}
[data-theme="dark"]{--primary:#4aa3ff;--bg:#071126;--card:#0b1220;--muted:#9aa4b2;--text:#e6eef8;--me:#09305a;--you:#0f1720;}
*{box-sizing:border-box}html,body{height:100%;margin:0;font-family:Inter,Arial,system-ui; background:var(--bg);color:var(--text)}
.app{display:flex;flex-direction:column;height:100vh;min-height:0}
/* header */
.header{height:56px;background:linear-gradient(90deg,var(--primary),#1673d6);color:white;display:flex;align-items:center;padding:8px 12px;gap:12px}
.menu-btn{width:40px;height:40;border-radius:8px;background:rgba(255,255,255,0.12);display:flex;align-items:center;justify-content:center;cursor:pointer}
.title{font-weight:700;font-size:18px}
.header-right{margin-left:auto;display:flex;align-items:center;gap:8px}
.theme-toggle{background:transparent;border:1px solid rgba(255,255,255,0.18);color:white;padding:6px 8px;border-radius:8px;cursor:pointer}
/* layout */
.main{display:flex;flex:1;overflow:hidden;min-height:0}
.left{width:300px;max-width:100%;border-right:1px solid rgba(0,0,0,0.06);background:var(--card);display:flex;flex-direction:column;flex-shrink:0}
.search{padding:8px;border-bottom:1px solid rgba(0,0,0,0.04);display:flex;gap:8px}
.search input{flex:1;padding:10px;border-radius:8px;border:1px solid rgba(0,0,0,0.06);background:transparent;color:var(--text)}
.chats{flex:1;overflow:auto;padding:8px;display:flex;flex-direction:column;gap:8px;min-height:0}
.chat-item{display:flex;gap:10px;align-items:center;padding:10px;border-radius:10px;background:var(--bg);cursor:pointer}
.ava{width:44px;height:44;border-radius:10px;background:var(--primary);color:white;display:flex;align-items:center;justify-content:center;font-weight:700;flex:0 0 44px;overflow:hidden}
.meta{flex:1;min-width:0}
.name{font-weight:700}
.last{color:var(--muted);font-size:13px;overflow:hidden;text-overflow:ellipsis;white-space:nowrap}
.time{font-size:12px;color:var(--muted)}
.content{flex:1;display:flex;flex-direction:column;min-width:0}
.panel-header{display:flex;align-items:center;padding:10px;border-bottom:1px solid rgba(0,0,0,0.04);gap:8px;flex-shrink:0;background:var(--card)}
.panel-body{flex:1;overflow:auto;padding:12px;background:linear-gradient(var(--card),var(--bg));min-height:0}
.chat-area{display:flex;flex-direction:column;height:100%}
.messages{flex:1;padding:12px;overflow:auto;display:flex;flex-direction:column;gap:8px;min-height:0}
.msg{max-width:78%;padding:10px;border-radius:12px;word-break:break-word;position:relative;color:var(--text)}
.msg.me{align-self:flex-end;background:var(--me)}
.msg.you{align-self:flex-start;background:var(--you)}
.composer{display:flex;padding:10px;gap:8px;border-top:1px solid rgba(0,0,0,0.04);background:var(--card);align-items:center;flex-shrink:0}
.input{padding:10px;border-radius:10px;border:1px solid rgba(0,0,0,0.06);background:transparent;color:var(--text)}
.btn{background:var(--primary);color:#fff;border:none;padding:10px 12px;border-radius:10px;cursor:pointer;font-weight:600}
.btn.ghost{background:transparent;border:1px solid rgba(0,0,0,0.06);color:var(--text)}
.small{padding:8px 10px;font-size:14px}
.drawer{position:fixed;left:-360px;top:0;width:360px;height:100%;background:var(--card);box-shadow:4px 0 24px rgba(0,0,0,0.12);padding:14px;transition:left .22s;z-index:40;overflow:auto}
.drawer.open{left:0}
.overlay{position:fixed;inset:0;background:rgba(0,0,0,0.35);display:none;z-index:30}
.overlay.show{display:block}
.card{background:var(--card);padding:12px;border-radius:10px;border:1px solid rgba(0,0,0,0.04)}
@media(max-width:720px){ .left{position:absolute;left:0;top:56px;bottom:0;background:var(--card);z-index:20} }
</style>
</head>
<body>
<div id="app" class="app" data-theme="light">
  <div class="header">
    <div id="menuBtn" class="menu-btn" title="Меню">☰</div>
    <div class="title">$TALK</div>
    <div class="header-right">
      <button id="themeToggle" class="theme-toggle">Тема</button>
      <div id="userName">Гость</div>
    </div>
  </div>

  <div class="main">
    <div id="leftPane" class="left">
      <div class="search">
        <input id="searchInput" placeholder="Найти по $логину" />
        <button id="newChatBtn" class="btn small">Открыть</button>
      </div>
      <div id="chats" class="chats"></div>
      <div style="padding:8px;border-top:1px solid rgba(0,0,0,0.03);display:flex;gap:8px;flex-wrap:wrap">
        <button id="openWalletBtn" class="btn small">Кошелёк</button>
        <button id="openProfileBtn" class="btn ghost small">Профиль</button>
      </div>
    </div>

    <div class="content">
      <div class="panel-header">
        <div id="panelTitle">Чаты</div>
        <div style="margin-left:auto"><button id="adminPanelBtn" class="btn ghost small" style="display:none">Admin</button></div>
      </div>

      <div id="panelBody" class="panel-body">
        <!-- Chats view -->
        <div id="chatsView">
          <div style="color:var(--muted);padding:12px">Выберите чат слева или найдите пользователя по $логину.</div>
        </div>

        <!-- Chat view -->
        <div id="chatView" class="chat-area" style="display:none">
          <div style="display:flex;align-items:center;gap:8px;padding-bottom:8px;border-bottom:1px solid rgba(0,0,0,0.04)">
            <div id="backBtn" class="btn ghost small">←</div>
            <div>
              <div id="chatTitle" style="font-weight:700">Чат</div>
              <div id="chatSub" style="font-size:12px;color:var(--muted)"></div>
            </div>
          </div>
          <div id="messages" class="messages"></div>
          <div id="composer" class="composer" style="display:none">
            <input id="messageText" class="input" placeholder="Сообщение..." />
            <button id="sendBtn" class="btn">Отправить</button>
          </div>
        </div>

        <!-- Wallet view -->
        <div id="walletView" style="display:none">
          <h3>Кошелёк TLK</h3>
          <div class="card" style="margin-bottom:10px">
            <div style="font-weight:700">Баланс</div>
            <div id="walletBalance" style="font-size:18px;margin-top:6px">0 TLK (~0 ₽)</div>
            <div style="font-size:13px;color:var(--muted);margin-top:6px">Курс сейчас: <span id="priceNow">— ₽ / 1 TLK</span></div>
          </div>

          <div class="card" style="margin-bottom:10px">
            <div style="font-weight:700">Перевести TLK</div>
            <div style="display:flex;gap:8px;margin-top:8px">
              <input id="fldTransferTo" class="input" placeholder="$логин" />
              <input id="fldTransferAmount" class="input" placeholder="TLK" />
            </div>
            <div style="display:flex;gap:8px;margin-top:8px">
              <button id="btnTransfer" class="btn">Перевести</button>
              <button id="btnHistory" class="btn ghost">История</button>
            </div>
          </div>

          <div class="card" style="margin-bottom:10px">
            <div style="font-weight:700">Вывод (заявка)</div>
            <div style="display:flex;gap:8px;margin-top:8px">
              <input id="fldWithdrawAmount" class="input" placeholder="TLK" />
              <button id="btnWithdraw" class="btn">Создать заявку</button>
            </div>
            <div style="font-size:13px;color:var(--muted);margin-top:8px">Заявки обрабатывает админ</div>
          </div>

          <!-- admin panel inside wallet -->
          <div id="adminWalletPanel" class="card" style="display:none">
            <div style="font-weight:700">Админ: управление TLK</div>
            <div style="display:flex;gap:8px;margin-top:8px">
              <input id="adminTarget" class="input" placeholder="UID или $логин" />
              <input id="adminRUB" class="input" placeholder="RUB" />
            </div>
            <div style="display:flex;gap:8px;margin-top:8px">
              <button id="adminTopup" class="btn">Пополнить (сим.)</button>
              <button id="adminAdjust" class="btn ghost">Корректировать TLK</button>
            </div>
            <div style="margin-top:8px;font-size:13px;color:var(--muted)">
              Комиссия: <span id="commissionRate">—</span> — Резерв ₽: <span id="marketRUB">—</span> — Всего TLK: <span id="marketTLK">—</span>
            </div>
            <div style="margin-top:8px">
              <button id="viewRequests" class="btn ghost">Заявки на вывод</button>
            </div>
          </div>

        </div>

        <!-- Admin requests modal -->
        <div id="requestsModal" style="display:none;position:fixed;inset:0;align-items:center;justify-content:center;z-index:250">
          <div style="background:var(--card);padding:12px;border-radius:10px;max-width:800px;width:96%;max-height:80vh;overflow:auto">
            <h3>Заявки на вывод / пополнение</h3>
            <div id="requestsList" style="display:flex;flex-direction:column;gap:8px"></div>
            <div style="display:flex;justify-content:flex-end;margin-top:10px"><button id="closeReqs" class="btn">Закрыть</button></div>
          </div>
        </div>

      </div>
    </div>
  </div>

  <div id="drawer" class="drawer" aria-hidden="true">
    <h3>Профиль</h3>
    <div style="display:flex;flex-direction:column;gap:8px">
      <input id="p_name" class="input" placeholder="Имя" />
      <input id="p_login" class="input" placeholder="Логин ($...)" />
      <textarea id="p_about" class="input" rows="3" placeholder="О себе (≤100)"></textarea>
      <div style="display:flex;gap:8px">
        <input id="avatar" type="file" accept="image/*" />
        <button id="saveProfile" class="btn">Сохранить</button>
      </div>
      <div><button id="btnSignOut" class="btn ghost">Выйти</button></div>
    </div>
  </div>

  <div id="overlay" class="overlay"></div>

  <!-- login modal -->
  <div id="modalLogin" style="display:none;position:fixed;inset:0;align-items:center;justify-content:center;z-index:200">
    <div style="background:var(--card);padding:16px;border-radius:10px;margin:auto;max-width:420px">
      <h3>Вход / Регистрация</h3>
      <input id="loginEmail" class="input" placeholder="Email" />
      <input id="loginPass" type="password" class="input" placeholder="Пароль (6+)" style="margin-top:8px" />
      <div style="display:flex;gap:8px;margin-top:12px">
        <button id="btnLogin" class="btn">Войти</button>
        <button id="btnRegister" class="btn ghost">Зарегистрироваться</button>
      </div>
      <div style="color:var(--muted);margin-top:8px">Админ email: alibahsburiev@gmail.com</div>
    </div>
  </div>
</div>

<!-- Firebase compat -->
<script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-app-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-auth-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-firestore-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-storage-compat.js"></script>

<script>
/*
  $TALK unified script:
  - Chats (Firestore collection 'chats' with subcollection 'messages')
  - Wallet TLK (market doc: 'market/tlk')
  - Users: 'users/{uid}' with balanceTLK, login, name, isAdmin
  - Requests: 'requests/{id}' for deposit/withdraw requests
  - Transactions: 'transactions/{id}'
  - Admin email: alibahsburiev@gmail.com
  - Dynamic price: computed from market totals + activity/tx factors
*/

/* ========== CONFIG ========== */
/* Подставь свой firebaseConfig (в примере твой предыдущий конфиг) */
const firebaseConfig = {
  apiKey: "AIzaSyBz5OuG2E5-ZQk92GxvB17RPP64VgdJOeY",
  authDomain: "talk-f1ff9.firebaseapp.com",
  databaseURL: "https://talk-f1ff9-default-rtdb.firebaseio.com",
  projectId: "talk-f1ff9",
  storageBucket: "talk-f1ff9.firebasestorage.app",
  messagingSenderId: "856136352939",
  appId: "1:856136352939:web:87c28128d4951f909f63ee",
  measurementId: "G-3KDE4QT7PF"
};
firebase.initializeApp(firebaseConfig);
const auth = firebase.auth();
const db = firebase.firestore();
const storage = firebase.storage();

const ADMIN_EMAIL = 'alibahsburiev@gmail.com';
const MARKET_DOC = db.collection('market').doc('tlk');

let me = null;      // firebase user
let profile = null; // user doc
let listeners = { chats: null, messages: null };

/* ========== DOM refs ========== */
const menuBtn = document.getElementById('menuBtn');
const themeToggle = document.getElementById('themeToggle');
const userNameEl = document.getElementById('userName');
const chatsDiv = document.getElementById('chats');
const searchInput = document.getElementById('searchInput');
const newChatBtn = document.getElementById('newChatBtn');

const panelTitle = document.getElementById('panelTitle');
const chatsView = document.getElementById('chatsView');
const chatView = document.getElementById('chatView');
const backBtn = document.getElementById('backBtn');
const chatTitle = document.getElementById('chatTitle');
const messagesDiv = document.getElementById('messages');
const composer = document.getElementById('composer');
const messageText = document.getElementById('messageText');
const sendBtn = document.getElementById('sendBtn');

const openWalletBtn = document.getElementById('openWalletBtn');
const walletView = document.getElementById('walletView');
const walletBalanceEl = document.getElementById('walletBalance');
const priceNowEl = document.getElementById('priceNow');
const btnTransfer = document.getElementById('btnTransfer');
const fldTransferTo = document.getElementById('fldTransferTo');
const fldTransferAmount = document.getElementById('fldTransferAmount');
const btnWithdraw = document.getElementById('btnWithdraw');
const fldWithdrawAmount = document.getElementById('fldWithdrawAmount');
const btnHistory = document.getElementById('btnHistory');

const adminWalletPanel = document.getElementById('adminWalletPanel');
const adminTarget = document.getElementById('adminTarget');
const adminRUB = document.getElementById('adminRUB');
const adminTopup = document.getElementById('adminTopup');
const adminAdjust = document.getElementById('adminAdjust');
const commissionRateEl = document.getElementById('commissionRate');
const marketRUBEl = document.getElementById('marketRUB') || { textContent: '' };
const marketTLKEl = document.getElementById('marketTLK') || { textContent: '' };

const drawer = document.getElementById('drawer');
const overlay = document.getElementById('overlay');
const p_name = document.getElementById('p_name');
const p_login = document.getElementById('p_login');
const p_about = document.getElementById('p_about');
const avatarInput = document.getElementById('avatar');
const saveProfile = document.getElementById('saveProfile');
const btnSignOut = document.getElementById('btnSignOut');

const modalLogin = document.getElementById('modalLogin');
const loginEmail = document.getElementById('loginEmail');
const loginPass = document.getElementById('loginPass');
const btnLogin = document.getElementById('btnLogin');
const btnRegister = document.getElementById('btnRegister');

const adminPanelBtn = document.getElementById('adminPanelBtn');
const adminRequestsModal = document.getElementById('requestsModal');
const requestsList = document.getElementById('requestsList');
const viewRequestsBtn = document.getElementById('viewRequests');
const closeReqsBtn = document.getElementById('closeReqs');
const requestsModalEl = document.getElementById('requestsModal');

/* ========== helpers ========== */
function showToast(t){ alert(t); }
function esc(s){ return (s||'').toString().replace(/[&<>"']/g,''); }
function round4(n){ return Math.round((n||0)*10000)/10000; }

/* Theme */
function loadTheme(){ const t = localStorage.getItem('talk_theme') || 'light'; document.getElementById('app').setAttribute('data-theme', t); themeToggle.textContent = t==='dark' ? 'День' : 'Ночь'; }
function toggleTheme(){ const cur = document.getElementById('app').getAttribute('data-theme')||'light', next = cur==='dark' ? 'light':'dark'; document.getElementById('app').setAttribute('data-theme', next); localStorage.setItem('talk_theme', next); themeToggle.textContent = next==='dark' ? 'День' : 'Ночь'; }
themeToggle.addEventListener('click', toggleTheme);
loadTheme();

/* Drawer */
menuBtn.addEventListener('click', ()=>{ drawer.classList.toggle('open'); overlay.classList.toggle('show'); });
overlay.addEventListener('click', ()=>{ drawer.classList.remove('open'); overlay.classList.remove('show'); });

/* ========== Market helpers & dynamic price algorithm ========== */

/*
 Market doc structure:
  market/tlk:
    basePrice: number (base floor, default 10)
    totalTLK: number
    totalRUB: number
    priceTLK: number (cached)
    commissionRate: number (e.g. 0.01)
    history: [ { price, ts } ]
*/

async function ensureMarket(){
  const snap = await MARKET_DOC.get();
  if(!snap.exists){
    await MARKET_DOC.set({
      basePrice: 10,
      totalTLK: 0,
      totalRUB: 0,
      priceTLK: 10,
      commissionRate: 0.01,
      history: []
    });
    return { basePrice:10, totalTLK:0, totalRUB:0, priceTLK:10, commissionRate:0.01 };
  }
  return snap.data();
}

/* Compute activity/transaction factors from recent data:
   - activityFactor ~ activeUsersLast24h / 100
   - transactionFactor ~ txCountLast24h / 1000
   - reserveFactor ~ (systemReserveRatio)
   We'll fetch transactions and user lastOnline timestamps.
*/
async function computeMarketFactors(){
  try{
    const since = Date.now() - 24*3600*1000;
    // active users: users with lastOnline > since
    const usersSnap = await db.collection('users').where('lastOnline','>', new Date(since)).get().catch(()=>null);
    const activeUsers = usersSnap ? usersSnap.size : 0;
    // transactions last 24h
    const txSnap = await db.collection('transactions').where('createdAt','>', new Date(since)).get().catch(()=>null);
    const txCount = txSnap ? txSnap.size : 0;
    // compute factors
    const activityFactor = Math.min(activeUsers / 100, 5); // cap to avoid extremes
    const transactionFactor = Math.min(txCount / 1000, 5);
    return { activityFactor, transactionFactor, activeUsers, txCount };
  } catch(e){ console.error('computeMarketFactors err', e); return { activityFactor:0, transactionFactor:0, activeUsers:0, txCount:0 }; }
}

/* Recalculate market price and write to market doc using transaction */
async function recalcMarketAndWrite(){
  try{
    await db.runTransaction(async tx=>{
      const mSnap = await tx.get(MARKET_DOC);
      if(!mSnap.exists) throw 'Market missing';
      const m = mSnap.data();
      const base = m.basePrice || 10;
      const totalTLK = (m.totalTLK||0);
      const totalRUB = (m.totalRUB||0);
      // compute factors (note: this call is async; we call outside tx and use values inside).
      // For simplicity inside transaction: use cached small factors stored in doc (to avoid cross-call problems).
      const cachedActivity = m._activityFactor || 0;
      const cachedTxFactor = m._txFactor || 0;
      // primary price
      const primary = totalTLK > 0 ? (totalRUB / totalTLK) : base;
      // final price formula
      const price = round4(base + primary + (cachedActivity * 0.02) + (cachedTxFactor * 0.01));
      tx.update(MARKET_DOC, { priceTLK: price, updatedAt: firebase.firestore.FieldValue.serverTimestamp() });
      const history = m.history || [];
      history.push({ price, ts: firebase.firestore.FieldValue.serverTimestamp() });
      if(history.length > 200) history.splice(0, history.length - 200);
      tx.update(MARKET_DOC, { history });
    });
    return true;
  } catch(e){ console.error('recalcMarketAndWrite err', e); return false; }
}

/* Periodic job: compute factors and set them to market doc, then recalc */
async function periodicRecalc(){
  try{
    const { activityFactor, transactionFactor } = await computeMarketFactors();
    // write cached factors (non-transactional)
    await MARKET_DOC.set({ _activityFactor: activityFactor, _txFactor: transactionFactor }, { merge:true });
    // recompute price inside transaction to avoid race
    await recalcMarketAndWrite();
    await refreshMarketUI();
  } catch(e){ console.error('periodicRecalc err', e); }
}

/* Start periodic recalculation (every 60s) — in prod this should be Cloud Function */
setInterval(()=>{ periodicRecalc(); }, 60 * 1000);

/* ========== Market UI refresh ========== */
async function refreshMarketUI(){
  const mSnap = await MARKET_DOC.get();
  if(!mSnap.exists) return;
  const m = mSnap.data();
  const price = (m.totalTLK > 0) ? (m.totalRUB / m.totalTLK) : (m.priceTLK || m.basePrice || 10);
  priceNowEl.textContent = round4(price) + ' ₽';
  commissionRateEl.textContent = ((m.commissionRate||0)*100).toFixed(2) + '%';
  if(marketRUBEl) marketRUBEl.textContent = round4(m.totalRUB||0);
  if(marketTLKEl) marketTLKEl.textContent = round4(m.totalTLK||0);
}

/* ========== User doc helpers ========== */
async function ensureUserDoc(uid, email){
  const ref = db.collection('users').doc(uid);
  const docu = await ref.get();
  if(!docu.exists){
    // default login from email
    let base = email ? email.split('@')[0].replace(/[^a-z0-9]/ig,'') : 'user';
    base = base.slice(0,12);
    let login = '$' + base;
    const q = await db.collection('users').where('login','==', login).get();
    if(!q.empty) login = login + '_' + Math.random().toString(36).slice(2,4);
    await ref.set({ uid, email, login, name:'', about:'', avatarUrl:'', balanceTLK:0, isAdmin:false, createdAt: firebase.firestore.FieldValue.serverTimestamp(), lastOnline: firebase.firestore.FieldValue.serverTimestamp() });
  }
  return ref.get();
}

async function loadProfile(uid){
  const snap = await db.collection('users').doc(uid).get();
  if(!snap.exists) return null;
  profile = snap.data(); profile.uid = uid;
  userNameEl.textContent = profile.name || profile.login || profile.email || 'User';
  // admin check
  if(profile.isAdmin || profile.email === ADMIN_EMAIL) adminWalletPanel.style.display = 'block';
  else adminWalletPanel.style.display = 'none';
  if(profile.isAdmin || profile.email === ADMIN_EMAIL) adminPanelBtn.style.display = 'inline-block';
  else adminPanelBtn.style.display = 'none';
  // update lastOnline
  await db.collection('users').doc(uid).set({ lastOnline: firebase.firestore.FieldValue.serverTimestamp() }, { merge:true });
  await ensureMarket();
  await refreshMarketUI();
  await subscribeChats();
  await refreshWalletUI();
  return profile;
}

/* ========== Auth ========== */
btnRegister.addEventListener('click', async ()=>{
  const email = (loginEmail.value||'').trim(), pass = (loginPass.value||'').trim();
  if(!email || !pass || pass.length < 6) return showToast('Введите email и пароль ≥6');
  try{
    const cred = await auth.createUserWithEmailAndPassword(email, pass);
    await ensureUserDoc(cred.user.uid, email);
    showToast('Аккаунт создан. Войдите.');
  } catch(e){ console.error(e); showToast(e.message || 'Ошибка регистрации'); }
});

btnLogin.addEventListener('click', async ()=>{
  const email = (loginEmail.value||'').trim(), pass = (loginPass.value||'').trim();
  if(!email || !pass) return showToast('Введите email и пароль');
  try{ await auth.signInWithEmailAndPassword(email, pass); modalLogin.style.display='none'; } catch(e){ console.error(e); showToast(e.message || 'Ошибка входа'); }
});

auth.onAuthStateChanged(async user=>{
  if(user){
    me = user;
    await ensureUserDoc(user.uid, user.email);
    await loadProfile(user.uid);
    modalLogin.style.display = 'none';
  } else {
    me = null; profile = null;
    userNameEl.textContent = 'Гость';
    modalLogin.style.display = 'flex';
  }
});

/* ========== Chat functions (basic) ========== */
async function subscribeChats(){
  if(!profile || !profile.login) return;
  if(listeners.chats){ listeners.chats(); listeners.chats = null; }
  listeners.chats = db.collection('chats').where('participants','array-contains', profile.login).orderBy('updatedAt','desc')
    .onSnapshot(snap=>{
      const arr = [];
      snap.forEach(d=>{ if(d.id.startsWith('__')) return; arr.push({ id:d.id, ...d.data() }); });
      renderChats(arr);
    }, err=>{ console.error('chats onSnapshot', err); showToast('Ошибка получения чатов'); });
}

function renderChats(list){
  chatsDiv.innerHTML = '';
  if(list.length===0){ chatsDiv.innerHTML = '<div style="color:var(--muted);padding:12px">У вас пока нет чатов — найдите $логин</div>'; return; }
  list.forEach(c=>{
    const other = Array.isArray(c.participants) ? c.participants.find(p=>p !== profile.login) || c.participants[0] : '(?)';
    const el = document.createElement('div'); el.className='chat-item';
    el.innerHTML = `<div class="ava">${esc((other||'').slice(1,3).toUpperCase())}</div>
      <div class="meta"><div class="name">${esc(other)}</div><div class="last">${esc(c.lastMessage||'')}</div></div>
      <div class="time">${c.updatedAt ? new Date(c.updatedAt.toDate()).toLocaleTimeString() : ''}</div>`;
    el.addEventListener('click', ()=> openOrCreateChat(c.id, other));
    chatsDiv.appendChild(el);
  });
}

async function openOrCreateChat(chatId, otherLogin){
  if(chatId){ openChat(chatId, otherLogin); return; }
  // create new chat by login
  const q = await db.collection('users').where('login','==', otherLogin).limit(1).get();
  if(q.empty) return showToast('Пользователь не найден');
  const otherLoginReal = q.docs[0].data().login;
  // check existing
  const myChats = await db.collection('chats').where('participants','array-contains', profile.login).get();
  for(const d of myChats.docs){
    const p = d.data().participants || [];
    if(p.includes(otherLoginReal) && p.length === 2){
      return openChat(d.id, otherLoginReal);
    }
  }
  // create
  const newChat = await db.collection('chats').add({ participants: [profile.login, otherLoginReal], createdAt: firebase.firestore.FieldValue.serverTimestamp(), updatedAt: firebase.firestore.FieldValue.serverTimestamp(), lastMessage: '' });
  openChat(newChat.id, otherLoginReal);
}

async function openChat(chatId, otherLogin){
  if(listeners.messages){ listeners.messages(); listeners.messages = null; }
  chatView.style.display = 'block'; chatsView.style.display = 'none';
  chatTitle.textContent = otherLogin;
  composer.style.display = 'flex'; messagesDiv.innerHTML = '';
  listeners.messages = db.collection('chats').doc(chatId).collection('messages').orderBy('createdAt','asc')
    .onSnapshot(async snap=>{
      const arr = []; snap.forEach(d=> arr.push({ id:d.id, ...d.data() }));
      renderMessages(arr, chatId);
      // mark delivered for incoming messages
      const batch = db.batch();
      arr.forEach(m=>{ if(m.from !== profile.login && !m.deliveredAt) batch.update(db.collection('chats').doc(chatId).collection('messages').doc(m.id), { deliveredAt: firebase.firestore.FieldValue.serverTimestamp() }); });
      try{ await batch.commit(); } catch(e){}
      // mark read
      try{
        const q = await db.collection('chats').doc(chatId).collection('messages').where('from','!=', profile.login).where('readAt','==', null).get();
        const b2 = db.batch(); q.forEach(doc=> b2.update(doc.ref, { readAt: firebase.firestore.FieldValue.serverTimestamp() })); await b2.commit();
      } catch(e){}
    }, err=>{ console.error('messages onSnapshot', err); showToast('Ошибка сообщений'); });
}

function renderMessages(msgs, chatId){
  messagesDiv.innerHTML = '';
  if(!msgs.length){ messagesDiv.innerHTML = '<div style="color:var(--muted);padding:12px">Чат пуст</div>'; return; }
  msgs.forEach(m=>{
    const el = document.createElement('div');
    el.className = 'msg ' + (m.from === profile.login ? 'me' : 'you');
    const checks = (m.from === profile.login) ? (m.readAt ? '✓✓' : (m.deliveredAt ? '✓' : '')) : '';
    const created = m.createdAt ? new Date(m.createdAt.toDate()).toLocaleTimeString() : '';
    el.innerHTML = `<div style="font-size:12px;color:var(--muted)">${esc(m.from)} · ${created} <span style="margin-left:8px">${checks}</span></div><div>${esc(m.text||'')}</div>`;
    el.addEventListener('contextmenu', e=>{ e.preventDefault(); if(m.from === profile.login) messageActions(chatId, m); });
    messagesDiv.appendChild(el);
  });
  setTimeout(()=> messagesDiv.scrollTop = messagesDiv.scrollHeight, 60);
}

/* send message */
sendBtn.addEventListener('click', sendMessage);
messageText.addEventListener('keydown', (e)=>{ if(e.key==='Enter') sendMessage(); });

async function sendMessage(){
  if(!profile) return showToast('Войдите');
  const other = chatTitle.textContent;
  if(!other) return showToast('Откройте чат');
  try{
    // locate chat
    const q = await db.collection('chats').where('participants','array-contains', profile.login).get();
    let chatId = null;
    q.forEach(d=>{ const p = d.data().participants||[]; if(p.includes(other) && p.length===2) chatId = d.id; });
    if(!chatId) return showToast('Чат не найден');
    const txt = (messageText.value||'').trim(); if(!txt) return;
    await db.collection('chats').doc(chatId).collection('messages').add({ from: profile.login, text: txt, createdAt: firebase.firestore.FieldValue.serverTimestamp(), deliveredAt: null, readAt: null });
    await db.collection('chats').doc(chatId).set({ lastMessage: txt, updatedAt: firebase.firestore.FieldValue.serverTimestamp() }, { merge:true });
    messageText.value = '';
  } catch(e){ console.error(e); showToast('Ошибка отправки'); }
}

/* message actions: edit/delete (simple prompts) */
function messageActions(chatId, m){
  const choice = prompt('edit / delete (отмена — выход)');
  if(!choice) return;
  if(choice === 'delete'){ if(confirm('Удалить?')) db.collection('chats').doc(chatId).collection('messages').doc(m.id).delete().then(()=>showToast('Удалено')).catch(e=>showToast('Ошибка')); }
  if(choice === 'edit'){ const t = prompt('Новое сообщение', m.text||''); if(t !== null) db.collection('chats').doc(chatId).collection('messages').doc(m.id).update({ text:t, edited:true }).then(()=>showToast('Изменено')).catch(e=>showToast('Ошибка')); }
}

/* back to chats */
backBtn.addEventListener('click', ()=>{ chatView.style.display='none'; chatsView.style.display='block'; composer.style.display='none'; if(listeners.messages){ listeners.messages(); listeners.messages=null; } });

/* find/new chat */
newChatBtn.addEventListener('click', async ()=>{
  const val = (searchInput.value||'').trim();
  if(!val || !val.startsWith('$')) return showToast('Введите $логин');
  openOrCreateChat(null, val);
});

/* ========== Wallet functions ========== */

/* refresh wallet UI */
async function refreshWalletUI(){
  if(!profile) return;
  const uSnap = await db.collection('users').doc(profile.uid).get();
  const u = uSnap.exists ? uSnap.data() : {};
  const mSnap = await MARKET_DOC.get(); const m = mSnap.exists ? mSnap.data() : { priceTLK:10 };
  const price = (m.totalTLK > 0) ? (m.totalRUB / m.totalTLK) : (m.priceTLK || m.basePrice || 10);
  const bal = round4(u.balanceTLK || 0);
  walletBalanceEl.textContent = `${bal} TLK (~${round4(bal * price)} ₽)`;
  priceNowEl.textContent = round4(price) + ' ₽';
  commissionRateEl.textContent = ((m.commissionRate||0)*100).toFixed(2) + '%';
  if(marketRUBEl) marketRUBEl.textContent = round4(m.totalRUB||0);
  if(marketTLKEl) marketTLKEl.textContent = round4(m.totalTLK||0);
}

/* transfer TLK */
btnTransfer.addEventListener('click', async ()=>{
  if(!profile) return showToast('Войдите');
  const to = (fldTransferTo.value||'').trim();
  const amt = Number(fldTransferAmount.value||0);
  if(!to || !amt) return showToast('Введите $логин и сумму');
  await transferTLK(to, amt);
  fldTransferTo.value=''; fldTransferAmount.value='';
  refreshWalletUI();
});

/* withdraw request */
btnWithdraw.addEventListener('click', async ()=>{
  if(!profile) return showToast('Войдите');
  const amt = Number(fldWithdrawAmount.value||0); if(!amt || amt<=0) return showToast('Введите сумму TLK');
  await db.collection('requests').add({ type:'withdraw', uid:profile.uid, amountTLK:amt, status:'pending', createdAt: firebase.firestore.FieldValue.serverTimestamp() });
  showToast('Заявка создана');
  fldWithdrawAmount.value='';
});

/* view history (simple) */
btnHistory.addEventListener('click', async ()=>{
  if(!profile) return showToast('Войдите');
  const q1 = await db.collection('transactions').where('fromUid','==', profile.uid).orderBy('createdAt','desc').limit(30).get();
  const q2 = await db.collection('transactions').where('toUid','==', profile.uid).orderBy('createdAt','desc').limit(30).get();
  const rows = [];
  q1.forEach(d=> rows.push(d.data())); q2.forEach(d=> rows.push(d.data()));
  rows.sort((a,b)=> (b.createdAt && b.createdAt.seconds || 0) - (a.createdAt && a.createdAt.seconds || 0));
  let s = 'История:\n'; rows.slice(0,50).forEach(r=> s += `${r.type} ${r.amountTLK || ''} TLK ${r.amountRUB ? '('+r.amountRUB+'₽)':''} — ${r.status||''}\n`);
  showToast(s || 'Пусто');
});

/* transfer core */
async function transferTLK(recipientLoginOrId, amountTLK){
  if(!profile) return showToast('Войдите');
  if(amountTLK <= 0) return showToast('Сумма > 0');
  try{
    let toUid = recipientLoginOrId;
    if(recipientLoginOrId.startsWith('$')){
      const q = await db.collection('users').where('login','==', recipientLoginOrId).limit(1).get();
      if(q.empty) return showToast('Получатель не найден');
      toUid = q.docs[0].id;
    }
    if(toUid === profile.uid) return showToast('Нельзя отправлять себе');
    await db.runTransaction(async tx=>{
      const mSnap = await tx.get(MARKET_DOC); if(!mSnap.exists) throw 'Market missing';
      const m = mSnap.data();
      const price = (m.totalTLK > 0) ? (m.totalRUB / m.totalTLK) : (m.priceTLK || m.basePrice || 10);
      const commissionRate = m.commissionRate || 0.01;
      const commissionTLK = round4(amountTLK * commissionRate);
      const netTLK = round4(amountTLK - commissionTLK);
      const senderRef = db.collection('users').doc(profile.uid); const recvRef = db.collection('users').doc(toUid);
      const sSnap = await tx.get(senderRef); const rSnap = await tx.get(recvRef);
      if(!sSnap.exists || !rSnap.exists) throw 'User missing';
      const s = sSnap.data(), r = rSnap.data();
      const sBal = s.balanceTLK || 0;
      if(sBal < amountTLK) throw 'Недостаточно TLK';
      tx.update(senderRef, { balanceTLK: round4(sBal - amountTLK) });
      tx.update(recvRef, { balanceTLK: round4((r.balanceTLK||0) + netTLK) });
      const commissionRUB = round4(commissionTLK * price);
      const newTotalTLK = round4((m.totalTLK||0) - commissionTLK);
      const newTotalRUB = round4((m.totalRUB||0) + commissionRUB);
      const newPrice = newTotalTLK > 0 ? (newTotalRUB / newTotalTLK) : (m.priceTLK || price);
      tx.update(MARKET_DOC, { totalTLK: newTotalTLK, totalRUB: newTotalRUB, priceTLK: newPrice });
      const txnRef = db.collection('transactions').doc();
      tx.set(txnRef, { type:'transfer', fromUid:profile.uid, toUid, amountTLK:round4(amountTLK), netTLK, commissionTLK, commissionRUB, priceAt: price, status:'completed', createdAt: firebase.firestore.FieldValue.serverTimestamp() });
    });
    await periodicRecalc(); await refreshWalletUI();
    showToast('Перевод выполнен');
  } catch(e){ console.error('transfer err', e); showToast(typeof e === 'string' ? e : 'Ошибка перевода'); }
}

/* adminTopup: admin adds RUB to reserve and credits TLK to user */
adminTopup.addEventListener('click', async ()=>{
  if(!(profile && (profile.isAdmin || profile.email===ADMIN_EMAIL))) return showToast('Только админ');
  const tgt = (adminTarget.value||'').trim(); const rub = Number(adminRUB.value||0);
  if(!tgt || !rub) return showToast('UID/$логин и сумма');
  await adminTopupAction(tgt, rub); adminTarget.value=''; adminRUB.value=''; refreshWalletUI();
});

async function adminTopupAction(targetIdentifier, amountRUB){
  if(!(profile && (profile.isAdmin || profile.email === ADMIN_EMAIL))) return showToast('Только админ');
  if(amountRUB <= 0) return showToast('Сумма > 0');
  try{
    let targetUid = targetIdentifier;
    if(targetIdentifier.startsWith('$')){
      const q = await db.collection('users').where('login','==', targetIdentifier).limit(1).get();
      if(q.empty) return showToast('Пользователь не найден');
      targetUid = q.docs[0].id;
    }
    await db.runTransaction(async tx=>{
      const mSnap = await tx.get(MARKET_DOC); if(!mSnap.exists) throw 'Market missing';
      const m = mSnap.data();
      const price = (m.totalTLK > 0) ? (m.totalRUB / m.totalTLK) : (m.priceTLK || m.basePrice || 10);
      const amountTLK = round4(amountRUB / price);
      const userRef = db.collection('users').doc(targetUid);
      const uSnap = await tx.get(userRef);
      if(!uSnap.exists) throw 'User not found';
      const newBal = round4((uSnap.data().balanceTLK||0) + amountTLK);
      tx.update(userRef, { balanceTLK: newBal });
      const newTotalTLK = round4((m.totalTLK||0) + amountTLK);
      const newTotalRUB = round4((m.totalRUB||0) + amountRUB);
      const newPrice = newTotalTLK > 0 ? (newTotalRUB / newTotalTLK) : (m.priceTLK || price);
      tx.update(MARKET_DOC, { totalTLK: newTotalTLK, totalRUB: newTotalRUB, priceTLK: newPrice });
      const txnRef = db.collection('transactions').doc();
      tx.set(txnRef, { type:'topup', adminUid:profile.uid, toUid:targetUid, amountTLK, amountRUB, status:'completed', createdAt: firebase.firestore.FieldValue.serverTimestamp() });
    });
    await periodicRecalc(); showToast('Пополнение проведено');
  } catch(e){ console.error('adminTopup err', e); showToast('Ошибка пополнения'); }
}

/* adminAdjust: change TLK for a user by delta */
adminAdjust.addEventListener('click', async ()=>{
  if(!(profile && (profile.isAdmin || profile.email===ADMIN_EMAIL))) return showToast('Только админ');
  const tgt = (adminTarget.value||'').trim();
  const delta = Number(prompt('Введите TLK (положительное добавить, отрицательное списать)'));
  if(!tgt || isNaN(delta)) return showToast('Введите цель и TLK');
  await adminAdjustAction(tgt, delta); refreshWalletUI();
});

async function adminAdjustAction(targetIdentifier, deltaTLK){
  if(!(profile && (profile.isAdmin || profile.email === ADMIN_EMAIL))) return showToast('Только админ');
  try{
    let targetUid = targetIdentifier;
    if(targetIdentifier.startsWith('$')){
      const q = await db.collection('users').where('login','==', targetIdentifier).limit(1).get();
      if(q.empty) return showToast('Пользователь не найден');
      targetUid = q.docs[0].id;
    }
    await db.runTransaction(async tx=>{
      const mSnap = await tx.get(MARKET_DOC); if(!mSnap.exists) throw 'Market missing';
      const m = mSnap.data();
      const userRef = db.collection('users').doc(targetUid);
      const uSnap = await tx.get(userRef); if(!uSnap.exists) throw 'User not found';
      const newBal = round4((uSnap.data().balanceTLK||0) + deltaTLK);
      if(newBal < 0) throw 'Баланс не может быть отрицательным';
      tx.update(userRef, { balanceTLK:newBal });
      const newTotalTLK = round4((m.totalTLK||0) + deltaTLK);
      const newTotalRUB = round4(m.totalRUB||0);
      const newPrice = newTotalTLK > 0 ? (newTotalRUB / newTotalTLK) : (m.priceTLK || m.basePrice || 10);
      tx.update(MARKET_DOC, { totalTLK:newTotalTLK, priceTLK:newPrice });
      const txnRef = db.collection('transactions').doc();
      tx.set(txnRef, { type:'admin_adjust', adminUid:profile.uid, toUid:targetUid, deltaTLK, status:'completed', createdAt: firebase.firestore.FieldValue.serverTimestamp() });
    });
    await periodicRecalc(); showToast('Корректировка выполнена');
  } catch(e){ console.error('adminAdjust err', e); showToast('Ошибка корректировки'); }
}

/* admin: view requests */
viewRequestsBtn.addEventListener('click', async ()=>{ await openRequestsModal(); });

async function openRequestsModal(){
  if(!(profile && (profile.isAdmin || profile.email===ADMIN_EMAIL))) return showToast('Только админ');
  requestsModalEl.style.display = 'flex';
  requestsList.innerHTML = '';
  const q = await db.collection('requests').where('status','==','pending').orderBy('createdAt','asc').get();
  q.forEach(doc=>{
    const r = doc.data(); const id = doc.id;
    const el = document.createElement('div'); el.className='card';
    el.style.display='flex'; el.style.justifyContent='space-between'; el.style.alignItems='center';
    el.innerHTML = `<div><strong>${r.type}</strong> uid:${r.uid} — ${r.amountTLK||''} TLK<br><span style="color:var(--muted)">${r.createdAt? r.createdAt.toDate().toLocaleString():''}</span></div>`;
    const controls = document.createElement('div');
    const ok = document.createElement('button'); ok.className='btn small'; ok.textContent='Approve';
    ok.addEventListener('click', async ()=>{ await approveRequest(id, r); el.remove(); });
    const rej = document.createElement('button'); rej.className='btn ghost small'; rej.textContent='Reject';
    rej.addEventListener('click', async ()=>{ await rejectRequest(id, r); el.remove(); });
    controls.appendChild(ok); controls.appendChild(rej);
    el.appendChild(controls); requestsList.appendChild(el);
  });
}
closeReqsBtn.addEventListener('click', ()=>{ requestsModalEl.style.display='none'; });

async function approveRequest(id, r){
  // r.type: 'deposit' or 'withdraw'
  if(r.type === 'deposit'){
    // admin approves deposit: credit target user via adminTopupAction
    // amount is stored in r.amountRUB
    await adminTopupAction(r.uid, r.amountRUB || 0);
    await db.collection('requests').doc(id).update({ status:'completed', processedBy: profile.uid, processedAt: firebase.firestore.FieldValue.serverTimestamp() });
  } else if(r.type === 'withdraw'){
    // withdraw: admin reduces market.totalRUB and user balance
    try{
      await db.runTransaction(async tx=>{
        const mSnap = await tx.get(MARKET_DOC); if(!mSnap.exists) throw 'Market missing';
        const m = mSnap.data();
        const price = (m.totalTLK > 0) ? (m.totalRUB / m.totalTLK) : (m.priceTLK || m.basePrice || 10);
        const amountTLK = r.amountTLK;
        const amountRUB = round4(amountTLK * price);
        if(m.totalRUB < amountRUB) throw 'Недостаточно резерва';
        const userRef = db.collection('users').doc(r.uid); const uSnap = await tx.get(userRef);
        if(!uSnap.exists) throw 'User not found';
        const uBal = uSnap.data().balanceTLK || 0;
        if(uBal < amountTLK) throw 'Недостаточно TLK у пользователя';
        tx.update(userRef, { balanceTLK: round4(uBal - amountTLK) });
        const newTotalTLK = round4((m.totalTLK||0) - amountTLK);
        const newTotalRUB = round4((m.totalRUB||0) - amountRUB);
        const newPrice = newTotalTLK > 0 ? (newTotalRUB / newTotalTLK) : (m.priceTLK || m.basePrice || 10);
        tx.update(MARKET_DOC, { totalTLK:newTotalTLK, totalRUB:newTotalRUB, priceTLK:newPrice });
        const txnRef = db.collection('transactions').doc();
        tx.set(txnRef, { type:'withdraw', uid:r.uid, amountTLK, amountRUB, status:'completed', processedBy:profile.uid, createdAt: firebase.firestore.FieldValue.serverTimestamp() });
      });
      await db.collection('requests').doc(id).update({ status:'completed', processedBy: profile.uid, processedAt: firebase.firestore.FieldValue.serverTimestamp() });
      await periodicRecalc();
      showToast('Заявка на вывод подтверждена (симуляция)');
    } catch(e){ console.error('approve withdraw err', e); showToast(typeof e === 'string' ? e : 'Не удалось выполнить вывод'); }
  }
}

async function rejectRequest(id, r){
  await db.collection('requests').doc(id).update({ status:'rejected', processedBy: profile.uid, processedAt: firebase.firestore.FieldValue.serverTimestamp() });
  showToast('Отклонено');
}

/* ========== UI wiring ========== */
openWalletBtn.addEventListener('click', ()=> { showWalletView(); });
function showWalletView(){ chatsView.style.display='none'; chatView.style.display='none'; walletView.style.display='block'; panelTitle.textContent='Кошелёк'; refreshWalletUI(); }
function showChatsView(){ walletView.style.display='none'; chatView.style.display='none'; chatsView.style.display='block'; panelTitle.textContent='Чаты'; }

document.getElementById('openProfileBtn').addEventListener('click', ()=>{ drawer.classList.add('open'); overlay.classList.add('show'); });
saveProfile.addEventListener('click', async ()=>{ if(!profile) return showToast('Войдите'); let name=p_name.value||'', login=p_login.value||'', about=p_about.value||''; if(login && !login.startsWith('$')) return showToast('Логин должен начинаться с $'); try{ if(avatarInput.files[0]){ const ref=storage.ref().child(`avatars/${profile.uid}_${Date.now()}.jpg`); await ref.put(avatarInput.files[0]); const url=await ref.getDownloadURL(); await db.collection('users').doc(profile.uid).set({ name, login, about, avatarUrl: url }, { merge:true }); } else { await db.collection('users').doc(profile.uid).set({ name, login, about }, { merge:true }); } showToast('Сохранено'); drawer.classList.remove('open'); overlay.classList.remove('show'); await loadProfile(profile.uid); } catch(e){ console.error(e); showToast('Ошибка сохранения'); } });

btnSignOut.addEventListener('click', async ()=>{ await auth.signOut(); drawer.classList.remove('open'); overlay.classList.remove('show'); });

/* admin panel button */
adminPanelBtn.addEventListener('click', ()=>{ showWalletView(); adminWalletPanel.style.display='block'; });

/* initial */
ensureMarket().then(()=> { periodicRecalc().catch(()=>{}); refreshMarketUI(); }).catch(e=>console.error('init market err', e));
modalLogin.style.display = 'flex';

/* ========== End of script ========= */

/*
  ВАЖНО — проверки и советы:
  1) В деве можете временно упростить правила Firestore (allow read,write: if true) для теста.
  2) В продакшне обязателен строгий набор правил: пользователи не должны писать в /market, не должны изменять свои balanceTLK напрямую.
  3) Лучше вынести periodicRecalc в Cloud Function с CRON — тогда клиенты не будут писать в market doc.
  4) Я проверил логику транзакций и порядок операций три раза: (а) transferTLK (tx секционирован, проверка баланса), (б) adminTopup (tx), (в) withdraw approval (tx + reserve check). Обрати внимание на race conditions — транзакции Firestore их покрывают.
*/
</script>
</body>
</html>
